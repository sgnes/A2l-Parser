ASAP2_VERSION 1 70
/begin PROJECT TestProject ""

/* File automatically generated by Hexwork  */
/* don't edit it manually !                 */

/begin HEADER ""
	VERSION "1"
	PROJECT_NO No
/end HEADER
/begin MODULE CPP ""
/begin A2ML



 struct Protocol_Layer {
 uint;  /* XCP protocol layer version 
 "1.5" = 0x0105 */
 uint;  /* T1 [ms] */
 uint;  /* T2 [ms] */
 uint;  /* T3 [ms] */
 uint;  /* T4 [ms] */
 uint;  /* T5 [ms] */
 uint;  /* T6 [ms] */
 uint;  /* T7 [ms] */
 uchar;  /* MAX_CTO */
 uint;  /* MAX_DTO default for DAQ and STIM */
 enum {
 "BYTE_ORDER_MSB_LAST" = 0,
 "BYTE_ORDER_MSB_FIRST" = 1
 };
 enum {
 "ADDRESS_GRANULARITY_BYTE" = 1,
 "ADDRESS_GRANULARITY_WORD" = 2,
 "ADDRESS_GRANULARITY_DWORD" = 4
 };
 taggedstruct {
 ("OPTIONAL_CMD" enum {
 "GET_COMM_MODE_INFO" = 251,
 "GET_ID" = 250,
 "SET_REQUEST" = 249,
 "GET_SEED" = 248,
 "UNLOCK" = 247,
 "SET_MTA" = 246,
 "UPLOAD" = 245,
 "SHORT_UPLOAD" = 244,
 "BUILD_CHECKSUM" = 243,
 "TRANSPORT_LAYER_CMD" = 242,
 "USER_CMD" = 241,
 "DOWNLOAD" = 240,
 "DOWNLOAD_NEXT" = 239,
 "DOWNLOAD_MAX" = 238,
 "SHORT_DOWNLOAD" = 237,
 "MODIFY_BITS" = 236,
 "SET_CAL_PAGE" = 235,
 "GET_CAL_PAGE" = 234,
 "GET_PAG_PROCESSOR_INFO" = 233,
 "GET_SEGMENT_INFO" = 232,
 "GET_PAGE_INFO" = 231,
 "SET_SEGMENT_MODE" = 230,
 "GET_SEGMENT_MODE" = 229,
 "COPY_CAL_PAGE" = 228,
 "CLEAR_DAQ_LIST" = 227,
 "SET_DAQ_PTR" = 226,
 "WRITE_DAQ" = 225,
 "SET_DAQ_LIST_MODE" = 224,
 "GET_DAQ_LIST_MODE" = 223,
 "START_STOP_DAQ_LIST" = 222,
 "START_STOP_SYNCH" = 221,
 "GET_DAQ_CLOCK" = 220,
 "READ_DAQ" = 219,
 "GET_DAQ_PROCESSOR_INFO" = 218,
 "GET_DAQ_RESOLUTION_INFO" = 217,
 "GET_DAQ_LIST_INFO" = 216,
 "GET_DAQ_EVENT_INFO" = 215,
 "FREE_DAQ" = 214,
 "ALLOC_DAQ" = 213,
 "ALLOC_ODT" = 212,
 "ALLOC_ODT_ENTRY" = 211,
 "PROGRAM_START" = 210,
 "PROGRAM_CLEAR" = 209,
 "PROGRAM" = 208,
 "PROGRAM_RESET" = 207,
 "GET_PGM_PROCESSOR_INFO" = 206,
 "GET_SECTOR_INFO" = 205,
 "PROGRAM_PREPARE" = 204,
 "PROGRAM_FORMAT" = 203,
 "PROGRAM_NEXT" = 202,
 "PROGRAM_MAX" = 201,
 "PROGRAM_VERIFY" = 200,
 "WRITE_DAQ_MULTIPLE" = 199,
 "TIME_CORRELATION_PROPERTIES" = 198,
 "DTO_CTR_PROPERTIES" = 197
 })*;
 ("OPTIONAL_LEVEL1_CMD" enum {
 "GET_VERSION" = 0,
 "SET_DAQ_PACKED_MODE" = 1,
 "GET_DAQ_PACKED_MODE" = 2,
 "SW_DBG_COMMAND_SPACE" = 252,
 "POD_COMMAND_SPACE" = 253
 })*;
 "COMMUNICATION_MODE_SUPPORTED" taggedunion {
 "BLOCK" taggedstruct {
 "SLAVE" ;  /* Slave Block Mode supported */
 "MASTER" struct {
 uchar;  /* MAX_BS */
 uchar;  /* MIN_ST */
 };
 };
 "INTERLEAVED" uchar;  /* QUEUE_SIZE */
 };
 "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function 
 including file extension 
 without path */
 "MAX_DTO_STIM" uint;  /* overrules MAX_DTO see above for STIM use case */
 block "ECU_STATES" taggedstruct {
 (block "STATE" struct {
 uchar;  /* STATE_NUMBER */
 char[100];  /* STATE_NAME */
 taggedstruct {
 "ECU_SWITCHED_TO_DEFAULT_PAGE" ;
 };
 enum {
 "NOT_ACTIVE" = 0,
 "ACTIVE" = 1,
 "GETTER_ONLY" = 2
 };
 enum {
 "NOT_ACTIVE" = 0,
 "ACTIVE" = 1
 };
 enum {
 "NOT_ACTIVE" = 0,
 "ACTIVE" = 1
 };
 enum {
 "NOT_ACTIVE" = 0,
 "ACTIVE" = 1
 };
 taggedstruct {
 (block "MEMORY_ACCESS" struct {
 uchar;  /* SEGMENT_NUMBER */
 uchar;  /* PAGE_NUMBER */
 enum {
 "READ_ACCESS_NOT_ALLOWED" = 0,
 "READ_ACCESS_ALLOWED" = 1
 };
 enum {
 "WRITE_ACCESS_NOT_ALLOWED" = 0,
 "WRITE_ACCESS_ALLOWED" = 1
 };
 })*;
 };
 })*;
 };
 };
 };

 struct Daq {
 enum {
 "STATIC" = 0,
 "DYNAMIC" = 1
 };
 uint;  /* MAX_DAQ */
 uint;  /* MAX_EVENT_CHANNEL */
 uchar;  /* MIN_DAQ */
 enum {
 "OPTIMISATION_TYPE_DEFAULT" = 0,
 "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
 "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
 "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
 "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
 "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
 };
 enum {
 "ADDRESS_EXTENSION_FREE" = 0,
 "ADDRESS_EXTENSION_ODT" = 1,
 "ADDRESS_EXTENSION_DAQ" = 3
 };
 enum {
 "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
 "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
 "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
 "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
 };
 enum {
 "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
 "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
 "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
 "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
 };
 uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ */
 enum {
 "NO_OVERLOAD_INDICATION" = 0,
 "OVERLOAD_INDICATION_PID" = 1,
 "OVERLOAD_INDICATION_EVENT" = 2
 };
 taggedstruct {
 "DAQ_ALTERNATING_SUPPORTED" uint;  /* Display_Event_Channel_Number */
 "PRESCALER_SUPPORTED" ;
 "RESUME_SUPPORTED" ;
 "STORE_DAQ_SUPPORTED" ;
 "DTO_CTR_FIELD_SUPPORTED" ;
 "OPTIMISATION_TYPE_ODT_STRICT" ;  /* strict mode shall only be used in combination with 
 OPTIMISATION_TYPE_ODT_TYPE_16 
 OPTIMISATION_TYPE_ODT_TYPE_32 
 OPTIMISATION_TYPE_ODT_TYPE_64 */
 block "STIM" struct {
 enum {
 "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
 "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
 "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
 "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
 };
 uchar;  /* MAX_ODT_ENTRY_SIZE_STIM */
 taggedstruct {
 "BIT_STIM_SUPPORTED" ;
 "MIN_ST_STIM" uchar;  /* separation time between DTOs 
 time in units of 100 microseconds */
 };
 };
 block "TIMESTAMP_SUPPORTED" struct {
 uint;  /* TIMESTAMP_TICKS */
 enum {
 "NO_TIME_STAMP" = 0,
 "SIZE_BYTE" = 1,
 "SIZE_WORD" = 2,
 "SIZE_DWORD" = 4
 };
 enum {
 "UNIT_1NS" = 0,
 "UNIT_10NS" = 1,
 "UNIT_100NS" = 2,
 "UNIT_1US" = 3,
 "UNIT_10US" = 4,
 "UNIT_100US" = 5,
 "UNIT_1MS" = 6,
 "UNIT_10MS" = 7,
 "UNIT_100MS" = 8,
 "UNIT_1S" = 9,
 "UNIT_1PS" = 10,
 "UNIT_10PS" = 11,
 "UNIT_100PS" = 12
 };
 taggedstruct {
 "TIMESTAMP_FIXED" ;
 };
 };
 "PID_OFF_SUPPORTED" ;
 "MAX_DAQ_TOTAL" uint;
 "MAX_ODT_TOTAL" uint;
 "MAX_ODT_DAQ_TOTAL" uint;
 "MAX_ODT_STIM_TOTAL" uint;
 "MAX_ODT_ENTRIES_TOTAL" uint;
 "MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
 "MAX_ODT_ENTRIES_STIM_TOTAL" uint;
 "CPU_LOAD_MAX_TOTAL" float;
 "CORE_LOAD_MAX_TOTAL" float;  /* max load of all cores */
 (block "CORE_LOAD_MAX" struct {
 uint;  /* CORE_NR: core reference number */
 float;  /* CORE_LOAD_MAX: max load of core(CORE_NR) */
 })*;
 block "DAQ_MEMORY_CONSUMPTION" struct {
 ulong;  /* DAQ_MEMORY_LIMIT: in Elements[AG] */
 uint;  /* DAQ_SIZE: number of elements[AG] per DAQ list */
 uint;  /* ODT_SIZE: number of elements[AG] per ODT */
 uint;  /* ODT_ENTRY_SIZE: number of elements[AG] per ODT_entry */
 uint;  /* ODT_DAQ_BUFFER_ELEMENT_SIZE: number of 
 payload elements[AG]*factor = sizeof(send buffer)[AG] */
 uint;  /* ODT_STIM_BUFFER_ELEMENT_SIZE: number of 
 payload elements[AG]*factor = sizeof(receive buffer)[AG] */
 taggedstruct {
 block "BUFFER_RESERVE" struct {
 uchar;  /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of 
 ODT_DAQ_BUFFER_ELEMENT_SIZE */
 uchar;  /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of 
 ODT_STIM_BUFFER_ELEMENT_SIZE */
 };
 };
 };
 (block "DAQ_LIST" struct {
 uint;  /* DAQ_LIST_NUMBER */
 taggedstruct {
 "DAQ_LIST_TYPE" enum {
 "DAQ" = 1,
 "STIM" = 2,
 "DAQ_STIM" = 3
 };
 "MAX_ODT" uchar;  /* MAX_ODT */
 "MAX_ODT_ENTRIES" uchar;  /* MAX_ODT_ENTRIES */
 "FIRST_PID" uchar;  /* FIRST_PID for this DAQ_LIST */
 "EVENT_FIXED" uint;  /* this DAQ_LIST always 
 in this event */
 "DAQ_PACKED_MODE_SUPPORTED" ;  /* supports DAQ packed mode */
 block "PREDEFINED" taggedstruct {
 (block "ODT" struct {
 uchar;  /* ODT number */
 taggedstruct {
 ("ODT_ENTRY" struct {
 uchar;  /* ODT_ENTRY number */
 ulong;  /* address of element */
 uchar;  /* address extension of element */
 uchar;  /* size of element [AG] */
 uchar;  /* BIT_OFFSET */
 })*;
 };  /* end of ODT_ENTRY */
 })*;  /* end of ODT */
 };  /* end of PREDEFINED */
 };
 })*;
 (block "EVENT" struct {
 char[101];  /* EVENT_CHANNEL_NAME */
 char[9];  /* EVENT_CHANNEL_SHORT_NAME */
 uint;  /* EVENT_CHANNEL_NUMBER */
 enum {
 "DAQ" = 1,
 "STIM" = 2,
 "DAQ_STIM" = 3
 };
 uchar;  /* MAX_DAQ_LIST */
 uchar;  /* EVENT_CHANNEL_TIME_CYCLE */
 uchar;  /* EVENT_CHANNEL_TIME_UNIT */
 uchar;  /* EVENT_CHANNEL_PRIORITY */
 taggedstruct {
 "COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint;  /* for compatibility reasons 
 not to be considered, if 1.3 Bypassing features are implemented */
 "CONSISTENCY" enum {
 "DAQ" = 0,
 "EVENT" = 1,
 "ODT" = 2,
 "NONE" = 3
 };
 "EVENT_COUNTER_PRESENT" ;
 "RELATED_EVENT_CHANNEL_NUMBER" uint;
 "RELATED_EVENT_CHANNEL_NUMBER_FIXED" ;  /* RELATED_EVENT_CHANNEL_NUMBER can not be modified. */
 "DTO_CTR_DAQ_MODE" enum {
 "INSERT_COUNTER" = 0,
 "INSERT_STIM_COUNTER_COPY" = 1
 };
 "DTO_CTR_DAQ_MODE_FIXED" ;  /* DTO_CTR_DAQ_MODE properties can not be modified. */
 "DTO_CTR_STIM_MODE" enum {
 "DO_NOT_CHECK_COUNTER" = 0,
 "CHECK_COUNTER" = 1
 };
 "DTO_CTR_STIM_MODE_FIXED" ;  /* DTO_CTR_STIM_MODE properties can not be modified */
 "STIM_DTO_CTR_COPY_PRESENT" ;  /* DTO CTR can be saved for later reference */
 block "DAQ_PACKED_MODE" struct {
 enum {
 "ELEMENT_GROUPED" = 1,
 "EVENT_GROUPED" = 2
 };
 enum {
 "STS_LAST" = 0,
 "STS_FIRST" = 1
 };
 enum {
 "OPTIONAL" = 0,
 "MANDATORY" = 1
 };
 uint;  /* DAQ packed mode sample count */
 taggedstruct {
 ("ALT_SAMPLE_COUNT" uint)*;  /* other valid sample count values (optional) */
 };
 };
 block "MIN_CYCLE_TIME" struct {
 uchar;  /* EVENT_CHANNEL_TIME_CYCLE */
 uchar;  /* EVENT_CHANNEL_TIME_UNIT */
 };
 block "BUFFER_RESERVE_EVENT" struct {
 uchar;  /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of ODT_DAQ_BUFFER_ELEMENT_SIZE */
 uchar;  /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of ODT_STIM_BUFFER_ELEMENT_SIZE */
 };
 "CPU_LOAD_MAX" float;
 block "CPU_LOAD_CONSUMPTION_DAQ" struct {
 float;  /* DAQ_FACTOR */
 float;  /* ODT_FACTOR */
 float;  /* ODT_ENTRY_FACTOR */
 taggedstruct {
 (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct {
 uint;  /* SIZE */
 float;  /* SIZE_FACTOR */
 })*;
 block "CORE_LOAD_EP" struct {
 uint;  /* CORE_NR: core reference number */
 float;  /* CORE_LOAD_EP_MAX: max load of this event part */
 };
 };
 };
 block "CPU_LOAD_CONSUMPTION_STIM" struct {
 float;  /* DAQ_FACTOR */
 float;  /* ODT_FACTOR */
 float;  /* ODT_ENTRY_FACTOR */
 taggedstruct {
 (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct {
 uint;  /* SIZE */
 float;  /* SIZE_FACTOR */
 })*;
 block "CORE_LOAD_EP" struct {
 uint;  /* CORE_NR: core reference number */
 float;  /* CORE_LOAD_EP_MAX: max load of this event part */
 };
 };
 };
 block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
 float;  /* ODT_FACTOR */
 float;  /* ODT_ELEMENT_LOAD: length in elements[AG] */
 taggedstruct {
 block "CORE_LOAD_EP" struct {
 uint;  /* CORE_NR: core reference number */
 float;  /* CORE_LOAD_EP_MAX: max load of this event part */
 };
 };
 };
 block "CPU_LOAD_CONSUMPTION_QUEUE_STIM" struct {
 float;  /* ODT_FACTOR */
 float;  /* ODT_ELEMENT_LOAD: length in elements[AG] */
 taggedstruct {
 block "CORE_LOAD_EP" struct {
 uint;  /* CORE_NR: core reference number */
 float;  /* CORE_LOAD_EP_MAX: max load of this event part */
 };
 };
 };
 };
 })*;
 };  /* end of optional at DAQ */
 };

 taggedunion Daq_Event {
 "FIXED_EVENT_LIST" taggedstruct {
 ("EVENT" uint)*;
 };
 "VARIABLE" taggedstruct {
 block "AVAILABLE_EVENT_LIST" taggedstruct {
 ("EVENT" uint)*;
 };
 block "DEFAULT_EVENT_LIST" taggedstruct {
 ("EVENT" uint)*;
 };
 block "CONSISTENCY_EVENT_LIST" taggedstruct {
 ("EVENT" uint)*;
 };
 };
 };

 struct Pag {
 uchar;  /* MAX_SEGMENTS */
 taggedstruct {
 "FREEZE_SUPPORTED" ;
 };
 };

 struct Pgm {
 enum {
 "PGM_MODE_ABSOLUTE" = 1,
 "PGM_MODE_FUNCTIONAL" = 2,
 "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
 };
 uchar;  /* MAX_SECTORS */
 uchar;  /* MAX_CTO_PGM */
 taggedstruct {
 (block "SECTOR" struct {
 char[101];  /* SECTOR_NAME */
 uchar;  /* SECTOR_NUMBER */
 ulong;  /* Address */
 ulong;  /* Length */
 uchar;  /* CLEAR_SEQUENCE_NUMBER */
 uchar;  /* PROGRAM_SEQUENCE_NUMBER */
 uchar;  /* PROGRAM_METHOD */
 })*;  /* end of SECTOR */
 "COMMUNICATION_MODE_SUPPORTED" taggedunion {
 "BLOCK" taggedstruct {
 "SLAVE" ;  /* Slave Block Mode supported */
 "MASTER" struct {
 uchar;  /* MAX_BS_PGM */
 uchar;  /* MIN_ST_PGM */
 };
 };
 "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM */
 };
 };
 };

 struct Segment {
 uchar;  /* SEGMENT_NUMBER */
 uchar;  /* number of pages */
 uchar;  /* ADDRESS_EXTENSION */
 uchar;  /* COMPRESSION_METHOD */
 uchar;  /* ENCRYPTION_METHOD */
 taggedstruct {
 block "CHECKSUM" struct {
 enum {
 "XCP_ADD_11" = 1,
 "XCP_ADD_12" = 2,
 "XCP_ADD_14" = 3,
 "XCP_ADD_22" = 4,
 "XCP_ADD_24" = 5,
 "XCP_ADD_44" = 6,
 "XCP_CRC_16" = 7,
 "XCP_CRC_16_CITT" = 8,
 "XCP_CRC_32" = 9,
 "XCP_USER_DEFINED" = 255
 };
 taggedstruct {
 "MAX_BLOCK_SIZE" ulong;  /* maximum block size 
 for checksum calculation */
 "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum function 
 including file extension 
 without path */
 "MTA_BLOCK_SIZE_ALIGN" uint;  /* required alignment of MTA and block size */
 };
 };
 "DEFAULT_PAGE_NUMBER" uchar;  /* Number of the default page */
 (block "PAGE" struct {
 uchar;  /* PAGE_NUMBER */
 enum {
 "ECU_ACCESS_NOT_ALLOWED" = 0,
 "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
 "ECU_ACCESS_WITH_XCP_ONLY" = 2,
 "ECU_ACCESS_DONT_CARE" = 3
 };
 enum {
 "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
 "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
 "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
 "XCP_READ_ACCESS_DONT_CARE" = 3
 };
 enum {
 "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
 "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
 "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
 "XCP_WRITE_ACCESS_DONT_CARE" = 3
 };
 taggedstruct {
 "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
 };
 })*;  /* end of PAGE */
 (block "ADDRESS_MAPPING" struct {
 ulong;  /* source address */
 ulong;  /* destination address */
 ulong;  /* length */
 })*;
 "PGM_VERIFY" ulong;  /* verification value for PGM */
 };  /* end of optional */
 };

 taggedstruct Time_Correlation {
 "DAQ_TIMESTAMPS_RELATE_TO" enum {
 "XCP_SLAVE_CLOCK" = 0,
 "ECU_CLOCK" = 1
 };
 (block "CLOCK" struct {
 char;  /* globally unique clock identifier (UUID/EUI), 1st octet (most significant byte) */
 char;  /* globally unique clock identifier (UUID/EUI), 2nd octet */
 char;  /* globally unique clock identifier (UUID/EUI), 3rd octet */
 char;  /* globally unique clock identifier (UUID/EUI), 4th octet */
 char;  /* globally unique clock identifier (UUID/EUI), 5th octet */
 char;  /* globally unique clock identifier (UUID/EUI), 6th octet */
 char;  /* globally unique clock identifier (UUID/EUI), 7th octet */
 char;  /* globally unique clock identifier (UUID/EUI), 8th octet (least significant byte) */
 enum {
 "XCP_SLAVE_CLOCK" = 0,
 "ECU_CLOCK" = 1,
 "XCP_SLAVE_GRANDMASTER_CLOCK" = 2,
 "ECU_GRANDMASTER_CLOCK" = 3
 };
 enum {
 "RANDOMLY_READABLE" = 0,
 "LIMITED_READABLE" = 1,
 "NOT_READABLE" = 2
 };
 enum {
 "SYN_UNSUPPORTED" = 0,
 "SYNCHRONIZATION_ONLY" = 1,
 "SYNTONIZATION_ONLY" = 2,
 "SYN_ALL" = 3
 };
 uchar;  /* clock quality, stratum level */
 taggedstruct {
 block "TIMESTAMP_CHARACTERIZATION" struct {
 uint;  /* TIMESTAMP_TICKS */
 enum {
 "UNIT_1NS" = 0,
 "UNIT_10NS" = 1,
 "UNIT_100NS" = 2,
 "UNIT_1US" = 3,
 "UNIT_10US" = 4,
 "UNIT_100US" = 5,
 "UNIT_1MS" = 6,
 "UNIT_10MS" = 7,
 "UNIT_100MS" = 8,
 "UNIT_1S" = 9,
 "UNIT_1PS" = 10,
 "UNIT_10PS" = 11,
 "UNIT_100PS" = 12
 };
 enum {
 "SIZE_FOUR_BYTE" = 4,
 "SIZE_EIGHT_BYTE" = 8
 };
 };
 };
 uint64;  /* MAX_TIMESTAMP_VALUE_BEFORE_WRAP_AROUND */
 enum {
 "ATOMIC_TIME" = 0,
 "UNIVERSAL_COORDINATED_TIME" = 1,
 "ARBITRARY" = 2
 };
 })*;
 };

 taggedstruct Common_Parameters {
 block "PROTOCOL_LAYER" struct Protocol_Layer;
 block "TIME_CORRELATION" taggedstruct Time_Correlation;
 block "SEGMENT" struct Segment;
 block "DAQ" struct Daq;
 block "PAG" struct Pag;
 block "PGM" struct Pgm;
 block "DAQ_EVENT" taggedunion Daq_Event;
 };

 struct CAN_Parameters {
 uint;  /* XCP on CAN version 
 "1.5" = 0x0105 */
 taggedstruct {
 "CAN_ID_BROADCAST" ulong;  /* Auto detection CAN-ID 
 master -> slaves 
 Bit31= 1: extended identifier 
 Bit30= 1: CAN-FD identifier */
 "CAN_ID_MASTER" ulong;  /* CMD/STIM CAN-ID 
 master -> slave 
 Bit31= 1: extended identifier 
 Bit30= 1: CAN-FD identifier */
 "CAN_ID_MASTER_INCREMENTAL" ;  /* master uses range of CAN-IDs 
 start of range = CAN_ID_MASTER 
 end of range = CAN_ID_MASTER+MAX_BS(_PGM)-1 */
 "CAN_ID_SLAVE" ulong;  /* RES/ERR/EV/SERV/DAQ CAN-ID 
 slave -> master 
 Bit31= 1: extended identifier 
 Bit30= 1: CAN-FD identifier */
 "CAN_ID_GET_DAQ_CLOCK_MULTICAST" ulong;  /* Only to be used for GET_DAQ_CLOCK_MULTICAST 
 master -> slaves 
 Bit31= 1: extended identifier 
 Bit30= 1: CAN-FD identifier */
 "BAUDRATE" ulong;  /* BAUDRATE [Hz] */
 "SAMPLE_POINT" uchar;  /* sample point 
 [% complete bit time] */
 "SAMPLE_RATE" enum {
 "SINGLE" = 1,
 "TRIPLE" = 3
 };
 "BTL_CYCLES" uchar;  /* BTL_CYCLES 
 [slots per bit time] */
 "SJW" uchar;  /* length synchr. segment 
 [BTL_CYCLES] */
 "SYNC_EDGE" enum {
 "SINGLE" = 1,
 "DUAL" = 2
 };
 "MAX_DLC_REQUIRED" ;  /* master to slave frames 
 always to have DLC = MAX_DLC = 8 */
 (block "DAQ_LIST_CAN_ID" struct {
 uint;  /* reference to DAQ_LIST_NUMBER */
 taggedstruct {
 "VARIABLE" ;
 "FIXED" ulong;  /* this DAQ_LIST always 
 on this CAN_ID */
 };
 })*;
 (block "EVENT_CAN_ID_LIST" struct {
 uint;  /* reference to EVENT_NUMBER */
 taggedstruct {
 ("FIXED" ulong)*;  /* this Event always on this ID */
 };
 })*;
 "MAX_BUS_LOAD" ulong;  /* maximum available bus 
 load in percent */
 "MEASUREMENT_SPLIT_ALLOWED" ;  /* Supports splitting of measurements to increase payload for MAX_DTO <= 8 */
 block "CAN_FD" struct {
 taggedstruct {
 "MAX_DLC" uint;  /* 8, 12, 16, 20, 24, 32, 48 or 64 */
 "CAN_FD_DATA_TRANSFER_BAUDRATE" ulong;  /* BAUDRATE [Hz] */
 "SAMPLE_POINT" uchar;  /* sample point receiver 
 [% complete bit time] */
 "BTL_CYCLES" uchar;  /* BTL_CYCLES 
 [slots per bit time] */
 "SJW" uchar;  /* length synchr. segment 
 [BTL_CYCLES] */
 "SYNC_EDGE" enum {
 "SINGLE" = 1,
 "DUAL" = 2
 };
 "MAX_DLC_REQUIRED" ;  /* master to slave frames 
 always to have DLC = MAX_DLC_for CAN-FD */
 "SECONDARY_SAMPLE_POINT" uchar;  /* sender sample point 
 [% complete bit time] */
 "TRANSCEIVER_DELAY_COMPENSATION" enum {
 "OFF" = 0,
 "ON" = 1
 };
 };
 };
 };
 taggedstruct {
 ("OPTIONAL_TL_SUBCMD" enum {
 "GET_SLAVE_ID" = 255,
 "GET_DAQ_ID" = 254,
 "SET_DAQ_ID" = 253,
 "GET_DAQ_CLOCK_MULTICAST" = 250
 })*;
 };
 };
 block "IF_DATA" taggedunion if_data {
 "CANAPE_EXT" struct {
 int;  /* version number, must be 100*/
 taggedstruct {
 "LINK_MAP" struct {
 char[256];  /* symbol name in MAP file*/
 long;  /* symbol base address in MAP file*/
 uint;  /* address extension*/
 uint;  /* flag: address is relative to DS*/
 long;  /* address offset to the symbol base address*/
 uint;  /* flag: data type information is valid*/
 uint;  /* data type of symbol in MAP file (CANape internal data type representation)*/
 uint;  /* bit offset of the symbol in MAP file*/
 };
 "DISPLAY" struct {
 long;  /* display color*/
 double;  /* minimal display value (phys)*/
 double;  /* maximal display value (phys)*/
 };
 "VIRTUAL_CONVERSION" struct {
 char[256];  /* name of the (additional) conversion formula*/
 };
 };
 };
 "XCPplus" struct {
 uint;  /* XCP plus AML structure version */
 taggedstruct Common_Parameters;  /* default parameters */
 taggedstruct {
 (block "XCP_ON_CAN" struct {
 struct CAN_Parameters;  /* specific for CAN */
 taggedstruct Common_Parameters;  /* overruling of default */
 taggedstruct {
 "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
 };
 })*;
 };
 };
 };
 

/end A2ML
		/begin IF_DATA XCPplus
		0x0105
		/begin PROTOCOL_LAYER
		0x0105
		0x0100
		0x0500
		0x0100
		0x0300
		0x0100
		0x0100
		0xFA
		0x40
		0x40
		BYTE_ORDER_MSB_LAST
		ADDRESS_GRANULARITY_BYTE
		OPTIONAL_CMD GET_DAQ_EVENT_INFO
		OPTIONAL_CMD SET_REQUEST
		OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
		OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
		OPTIONAL_CMD GET_DAQ_CLOCK
		OPTIONAL_CMD START_STOP_SYNCH
		OPTIONAL_CMD START_STOP_DAQ_LIST
		OPTIONAL_CMD GET_DAQ_LIST_MODE
		OPTIONAL_CMD SET_DAQ_LIST_MODE
		OPTIONAL_CMD SET_CAL_PAGE
		OPTIONAL_CMD GET_CAL_PAGE
		OPTIONAL_CMD WRITE_DAQ
		OPTIONAL_CMD SET_DAQ_PTR
		OPTIONAL_CMD ALLOC_ODT_ENTRY
		OPTIONAL_CMD ALLOC_ODT
		OPTIONAL_CMD ALLOC_DAQ
		OPTIONAL_CMD FREE_DAQ
		OPTIONAL_CMD DOWNLOAD_NEXT
		OPTIONAL_CMD BUILD_CHECKSUM
		OPTIONAL_CMD DOWNLOAD_MAX
		OPTIONAL_CMD SET_MTA
		OPTIONAL_CMD UPLOAD
		OPTIONAL_CMD COPY_CAL_PAGE
		COMMUNICATION_MODE_SUPPORTED BLOCK
		SLAVE
		MASTER
		0x04
		0x64
		/end PROTOCOL_LAYER
		/begin DAQ
		DYNAMIC
		0x03
		0x03
		0x00
		OPTIMISATION_TYPE_DEFAULT
		ADDRESS_EXTENSION_FREE
		IDENTIFICATION_FIELD_TYPE_ABSOLUTE
		GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
		0x64
		OVERLOAD_INDICATION_EVENT
		/begin DAQ_MEMORY_CONSUMPTION
		0x000032c5
		0x0030
		0x0010
		0x0005
		0x0001
		0x0002
		/begin BUFFER_RESERVE
		20
		40
		/end BUFFER_RESERVE
		/end DAQ_MEMORY_CONSUMPTION
		/begin STIM
		GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD
		0x00
		BIT_STIM_SUPPORTED
		/end STIM
		/begin EVENT
		"XcpEventChannel_1ms"
		"XEvC1ms"
		0x02
		DAQ
		0x01
		0x01
		0x06
		0x00
		/end EVENT
		/begin EVENT
		"XcpEventChannel_10ms"
		"XEvC10ms"
		0x00
		DAQ
		0x01
		0x0A
		0x06
		0x00
		/end EVENT
		/begin EVENT
		"XcpEventChannel_100ms"
		"XEvC100ms"
		0x01
		DAQ
		0x01
		0x64
		0x06
		0x00
		/end EVENT
		/end DAQ
		/begin XCP_ON_CAN
		0x0105
		CAN_ID_BROADCAST 0x00
		CAN_ID_MASTER 0xDBFFE600
		CAN_ID_SLAVE 0xDBFFE601
		BAUDRATE 500000
		SAMPLE_POINT 80
		SAMPLE_RATE SINGLE
		BTL_CYCLES 80
		SJW 16
		SYNC_EDGE SINGLE
		/begin CAN_FD
		MAX_DLC 64
		CAN_FD_DATA_TRANSFER_BAUDRATE 2000000
		SAMPLE_POINT 80
		BTL_CYCLES 20
		SJW 4
		SYNC_EDGE SINGLE
		MAX_DLC_REQUIRED
		SECONDARY_SAMPLE_POINT 80
		TRANSCEIVER_DELAY_COMPENSATION ON
		/end CAN_FD
		/end XCP_ON_CAN
		/end IF_DATA
	/begin MOD_PAR ""
		/begin MEMORY_SEGMENT PF1_APPL_SWID "PF1_APPL_SWID"
			RESERVED FLASH
INTERN 0xb0440040 0x200 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x00
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_CALIB_SWID "PF1_CALIB_SWID"
			RESERVED FLASH
INTERN 0xb05FC040 0x200 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x01
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_APPL_SW_BLOCK "PF1_APPL_SW_BLOCK"
			OFFLINE_DATA ROM
INTERN 0xb0440000 0x40 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x04
		0x02
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/begin PAGE
		0x01
		ECU_ACCESS_WITH_XCP_ONLY
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_OFFLINE_CALIB "PF1_OFFLINE_CALIB"
			OFFLINE_DATA ROM
INTERN 0xb0560000 0xb8000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x04
		0x02
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/begin PAGE
		0x01
		ECU_ACCESS_WITH_XCP_ONLY
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_LOGISTIC_OFFLINE_CALIB "PF1_LOGISTIC_OFFLINE_CALIB"
			OFFLINE_DATA ROM
INTERN 0xb05F8000 0x4040 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x04
		0x02
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/begin PAGE
		0x01
		ECU_ACCESS_WITH_XCP_ONLY
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_ONLINE_CALIB "PF1_ONLINE_CALIB"
			DATA FLASH
INTERN 0xb0500000 0x60000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x05
		0x02
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/begin PAGE
		0x01
		ECU_ACCESS_WITH_XCP_ONLY
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_WITH_ECU_ONLY
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF0_ASW_CODE_FAST_ASIL_C0 "PF0_ASW_CODE_FAST_ASIL_C0"
			CODE FLASH
INTERN 0xb00F8000 0xD000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x0C
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF0_BSW_CODE_FAST_ASIL_C0 "PF0_BSW_CODE_FAST_ASIL_C0"
			CODE FLASH
INTERN 0xb011C000 0x1800 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x0C
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF0_BSW_CODE_FAST_QM_C0 "PF0_BSW_CODE_FAST_QM_C0"
			CODE FLASH
INTERN 0xb01B4000 0xb00 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x0D
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF0_XX_CODE_FAST_QM_C0 "PF0_XX_CODE_FAST_QM_C0"
			CODE FLASH
INTERN 0xb0264000 0x1000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x0E
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_BSW_CODE_FAST_QM_C1 "PF1_BSW_CODE_FAST_QM_C1"
			CODE FLASH
INTERN 0xb0300000 0x400 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x0F
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_BSW_CODE_FAST_ASIL_C1 "PF1_BSW_CODE_FAST_ASIL_C1"
			CODE FLASH
INTERN 0xb030CA00 0x9400 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x10
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_XX_CODE_FAST_QM_C1 "PF1_XX_CODE_FAST_QM_C1"
			CODE FLASH
INTERN 0xb0348000 0xA000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x11
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_XX_CODE_FAST_QM_C2 "PF1_XX_CODE_FAST_QM_C2"
			CODE FLASH
INTERN 0xb0380000 0xF000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x12
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_BSW_CODE_FAST_QM_C2 "PF1_BSW_CODE_FAST_QM_C2"
			CODE FLASH
INTERN 0xb03A3000 0x1000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x13
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_BSW_CODE_FAST_QM_C3 "PF1_BSW_CODE_FAST_QM_C3"
			CODE FLASH
INTERN 0xb03B8000 0x2000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x14
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_ASW_CODE_FAST_QM_C3 "PF1_ASW_CODE_FAST_QM_C3"
			CODE FLASH
INTERN 0xb03C2000 0xE000 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x15
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT PF1_XX_CODE_FAST_ASIL_C1 "PF1_XX_CODE_FAST_ASIL_C1"
			CODE FLASH
INTERN 0xb032E400 0x6800 -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus
		0x0105
		/begin SEGMENT
		0x16
		0x01
		0x00
		0x00
		0x00
		/begin CHECKSUM
		XCP_CRC_16_CITT
		/end CHECKSUM
		/begin PAGE
		0x00
		ECU_ACCESS_DONT_CARE
		XCP_READ_ACCESS_WITH_ECU_ONLY
		XCP_WRITE_ACCESS_NOT_ALLOWED
		/end PAGE
		/end SEGMENT
		/end IF_DATA
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT dspr0 "RAM_Core0"
			CALIBRATION_VARIABLES RAM
INTERN 0x70000000 0x38000 -1 -1 -1 -1 -1
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT dspr1 "RAM_Core1"
			CALIBRATION_VARIABLES RAM
INTERN 0x60000000 0x38000 -1 -1 -1 -1 -1
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT dspr2 "RAM_Core2"
			CALIBRATION_VARIABLES RAM
INTERN 0x50000000 0x17000 -1 -1 -1 -1 -1
		/end MEMORY_SEGMENT
		/begin MEMORY_SEGMENT dspr3 "RAM_Core3"
			CALIBRATION_VARIABLES RAM
INTERN 0x40000000 0x17000 -1 -1 -1 -1 -1
		/end MEMORY_SEGMENT
	/end MOD_PAR
	/begin MOD_COMMON ""
		ALIGNMENT_BYTE 1
		ALIGNMENT_WORD 2
		ALIGNMENT_LONG 4
		ALIGNMENT_FLOAT16_IEEE 2
		ALIGNMENT_FLOAT32_IEEE 4
		ALIGNMENT_FLOAT64_IEEE 8
		ALIGNMENT_INT64 8
	/end MOD_COMMON
	/begin AXIS_PTS
		ca_Colu_xxTempMax
		"Curve axis for the target oil coolant volume flow depend on maximum temperature."
		0xb05368F0
		NO_INPUT_QUANTITY
		typF32_axis
		0
		cv_degC_float
		4
		-3.4e+38
		3.4e+38
		SYMBOL_LINK "ca_Colu_xxTempMax" 0
	/end AXIS_PTS
	/begin AXIS_PTS
		ca_Colu_Emtest
		"Curve axis for the target oil coolant volume flow depend on Em1 power losses."
		0xb05368DC
		NO_INPUT_QUANTITY
		typF32_axis
		0
		cv_W_float
		5
		-3.4e+38
		3.4e+38
		SYMBOL_LINK "ca_Colu_Emtest" 0
	/end AXIS_PTS
	/begin CHARACTERISTIC
		TestCalib1
		"-"
		VALUE
		0xb050C084 
		recVAL_UBYTE
		0
		COMPU_METHOD_FSW_XX
		0
		255
	/end CHARACTERISTIC
	/begin CHARACTERISTIC
		TestCalib2
		"-"
		VALUE
		0xb050C098 
		recVAL_UBYTE
		0
		COMPU_METHOD_FSW_XX
		0
		255
	/end CHARACTERISTIC
	/begin CHARACTERISTIC
		TestCalib3
		"-"
		VALUE
		0xb050C0AC 
		recVAL_UBYTE
		0
		COMPU_METHOD_FSW_XX
		0
		255
	/end CHARACTERISTIC
	/begin COMPU_METHOD cv_0_1A_A
		""
		RAT_FUNC
		"%5.0"
		"A"
		COEFFS 0 10 0 0 0 1
	/end COMPU_METHOD
	/begin COMPU_METHOD cv_0_1W_W
		""
		RAT_FUNC
		"%5.0"
		"W"
		COEFFS 0 10 0 0 0 1
	/end COMPU_METHOD
	/begin COMPU_VTAB enumTab_cv_Enum_SelInpPwr
		""
		TAB_VERB
		3
			0 "DERAT_SEL_INP_PWR_REQ"
			1 "DERAT_SEL_INP_PWR_ACT"
			2 "DERAT_SEL_INP_PWR_MAX_REQ_ACT"
	/end COMPU_VTAB
	/begin COMPU_VTAB enumTab_cv_Enum_TqCpbySelTqFilMode
		""
		TAB_VERB
		3
			0 "DERAT_SEL_FIL_NONE"
			1 "DERAT_SEL_FIL_MOVING_AVERAGE"
			2 "DERAT_SEL_FIL_GRADIENT"
	/end COMPU_VTAB
	/begin MEASUREMENT
		Testvar1
		"Number of 10 ms interrupts since startup. Wraps around when UI16 maximum is reached."
		UWORD
		cv_counter
		1
		1
		0
		65535
		ECU_ADDRESS 0x4000D944
		SYMBOL_LINK "Testvar1" 0
		/begin IF_DATA ETK_XETK
		DEFAULT_RASTERS 3
		/end IF_DATA
	/end MEASUREMENT
	/begin MEASUREMENT
		Testvar12
		"Testvar12"
		UWORD
		cv_counter
		1
		1
		0
		65535
		ECU_ADDRESS 0x4000D90C
		SYMBOL_LINK "Testvar12" 0
		/begin IF_DATA ETK_XETK
		DEFAULT_RASTERS 3
		/end IF_DATA
	/end MEASUREMENT

	/begin GROUP WDGM
		""
		/begin REF_MEASUREMENT
			WdgM_EB_GlobalStatus
			Testvar12
		/end REF_MEASUREMENT

	/end GROUP
	/begin FUNCTION status_handling_rps1
		""
		/begin LOC_MEASUREMENT
			 s_Srps_StatusSignalRps1        
		/end LOC_MEASUREMENT
	/end FUNCTION
	/begin FUNCTION status_handling_rps2
		""
		/begin LOC_MEASUREMENT
			 s_Srps_StatusSignalRps2        
		/end LOC_MEASUREMENT
	/end FUNCTION
	/begin RECORD_LAYOUT typUI8
		FNC_VALUES 1 UBYTE COLUMN_DIR DIRECT
	/end RECORD_LAYOUT
	/begin RECORD_LAYOUT typSI8_2D_Map
		FNC_VALUES 5 SBYTE ROW_DIR PLONG
		AXIS_PTS_X 3 SBYTE INDEX_INCR PLONG
		AXIS_PTS_Y 4 SBYTE INDEX_INCR PLONG
		NO_AXIS_PTS_X 1 SWORD
		NO_AXIS_PTS_Y 2 SWORD
	/end RECORD_LAYOUT
/end MODULE
/end PROJECT
